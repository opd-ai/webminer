<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket-to-Stratum Proxy Setup</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="miner-consent-banner" id="minerConsentBanner">
        <div class="miner-banner-content">
            <div class="miner-info">
                <h3>üöÄ Support This Site</h3>
                <p>Help keep this content free by contributing a small amount of computing power. This uses about 25% of your CPU and you can stop anytime.</p>
            </div>
            <div class="miner-controls">
                <button id="minerStartBtn" class="miner-btn miner-btn-primary">
                    ‚úì Yes, I'll Help
                </button>
                <button id="minerDeclineBtn" class="miner-btn miner-btn-secondary">
                    No Thanks
                </button>
            </div>
        </div>
    </div>
    
    <div class="miner-status-bar" id="minerStatusBar" style="display: none;">
        <div class="miner-status-content">
            <span class="miner-status-icon">‚ö°</span>
            <span class="miner-status-text">Mining Active</span>
            <span class="miner-status-stats" id="minerStats">0 H/s</span>
            <button id="minerStopBtn" class="miner-btn miner-btn-stop">Stop Mining</button>
        </div>
    </div>
    <nav class="site-nav">
        <a href="index.html">Home</a>
        <a href="ADDRESSING_THE_CRYPTO_BROS_CRITIQUE.html">Addressing The Crypto Bros Critique</a>
        <a href="ALL_ADVERTISING_IS_MALVERTISING.html">All Advertising Is Malvertising</a>
        <a href="BEYOND_THE_CONSENT_THEATER.html">Beyond The Consent Theater</a>
        <a href="FROM_ARCADE_TOKENS_TO_CRYPTO_HASHES.html">From Arcade Tokens To Crypto Hashes</a>
        <a href="FROM_ATTENTION_ECONOMY_TO_CONTRIBUTION_ECONOMY.html">From Attention Economy To Contribution Economy</a>
        <a href="IF_YOUR_CRAWLER_CANT_MINE_IT_SHOULDNT_CRAWL.html">If Your Crawler Cant Mine It Shouldnt Crawl</a>
        <a href="MINER_UI.html">Miner Ui</a>
        <a href="PRIVATE_MONEY_PRIVATE_ENERGY.html">Private Money Private Energy</a>
        <a href="SITE_GENERATOR.html">Site Generator</a>
        <a href="THE_ACCESSIBILITY_PARADOX.html">The Accessibility Paradox</a>
        <a href="THE_ATTENTION_TOXICITY_PROBLEM.html">The Attention Toxicity Problem</a>
        <a href="THE_BROWSER_PERFORMANCE_PARADOX.html">The Browser Performance Paradox</a>
        <a href="THE_COINHIVE_LESSON.html">The Coinhive Lesson</a>
        <a href="THE_COMPUTATIONAL_POLLUTION_PROBLEM.html">The Computational Pollution Problem</a>
        <a href="THE_CONSENT_GAP.html">The Consent Gap</a>
        <a href="THE_CRAWLERS_DEBT.html">The Crawlers Debt</a>
        <a href="THE_DEMOCRACY_OF_COMPUTING.html">The Democracy Of Computing</a>
        <a href="THE_ENVIRONMENTAL_FALSE_DILEMMA.html">The Environmental False Dilemma</a>
        <a href="THE_GLOBAL_SOUTHS_SECRET_WEAPON.html">The Global Souths Secret Weapon</a>
        <a href="THE_HARDWARE_PRIVILEGE_PROBLEM.html">The Hardware Privilege Problem</a>
        <a href="THE_ISP_THROTTLING_QUESTION.html">The Isp Throttling Question</a>
        <a href="THE_JUST_USE_A_VPN_FALLACY.html">The Just Use A Vpn Fallacy</a>
        <a href="THE_LOCAL_BUSINESS_RENAISSANCE.html">The Local Business Renaissance</a>
        <a href="THE_NONPROFIT_DILEMMA.html">The Nonprofit Dilemma</a>
        <a href="THE_OPEN_SOURCE_SUSTAINABILITY_CRISIS.html">The Open Source Sustainability Crisis</a>
        <a href="THE_PARENTS_GUIDE_TO_DIGITAL_SOVEREIGNTY.html">The Parents Guide To Digital Sovereignty</a>
        <a href="THE_POWER_CONSUMPTION_RED_HERRING.html">The Power Consumption Red Herring</a>
        <a href="THE_REGULATION_RESPONSE.html">The Regulation Response</a>
        <a href="THE_STREAMING_PARADOX.html">The Streaming Paradox</a>
        <a href="THE_SUBSCRIPTION_FATIGUE_SOLUTION.html">The Subscription Fatigue Solution</a>
        <a href="THE_TRAINING_DATA_RECKONING.html">The Training Data Reckoning</a>
        <a href="THE_TRUST_PROBLEM.html">The Trust Problem</a>
        <a href="THE_VOLATILITY_REALITY_CHECK.html">The Volatility Reality Check</a>
        <a href="WEBMINING_IS_NOT_EVIL.html">Webmining Is Not Evil</a>
        <a href="WEBSOCKET_PROXY.html" class="active">Websocket Proxy</a>
        <a href="YOUR_COMPUTER_ALREADY_WORKS_FOR_FREE.html">Your Computer Already Works For Free</a>
    </nav>
    <main class="content">
<h1>WebSocket-to-Stratum Proxy Setup</h1>

<h2>Why You Need a Proxy</h2>

<strong>Important</strong>: Most Monero mining pools (including SupportXMR, MoneroOcean, etc.) use the <strong>TCP Stratum protocol</strong>, not WebSocket. Browsers cannot make direct TCP connections due to security restrictions, so WebMiner requires a WebSocket-to-Stratum proxy to bridge the connection.

<h2>The Problem</h2>

<pre><code>Browser (WebMiner) --[WebSocket]--&gt; ‚ùå --[TCP Stratum]--&gt; Mining Pool
                                   Cannot connect directly!
</code></pre>

<h2>The Solution</h2>

<pre><code>Browser (WebMiner) --[WebSocket]--&gt; Proxy --[TCP Stratum]--&gt; Mining Pool
                                     ‚úÖ Bridges the protocols
</code></pre>

<h2>Quick Setup with Node.js Proxy</h2>

<h3>1. Install Dependencies</h3>

<pre><code class="language-bash">mkdir webminer-proxy
cd webminer-proxy
npm init -y
npm install ws net
</code></pre>

<h3>2. Create Proxy Server (<code>proxy.js</code>)</h3>

<pre><code class="language-javascript">const WebSocket = require('ws');
const net = require('net');

const WS_PORT = 8080;  // WebSocket port for browsers
const POOL_HOST = 'gulf.moneroocean.stream';  // Stratum pool
const POOL_PORT = 10128;  // Stratum port

const wss = new WebSocket.Server({ port: WS_PORT });

console.log(<code>WebSocket-to-Stratum proxy listening on ws://localhost:${WS_PORT}</code>);
console.log(<code>Forwarding to ${POOL<em>HOST}:${POOL</em>PORT}</code>);

wss.on('connection', (ws) =&gt; {
    console.log('Browser client connected');
    
    // Create TCP connection to pool
    const poolSocket = net.connect(POOL<em>PORT, POOL</em>HOST, () =&gt; {
        console.log('Connected to mining pool');
    });
    
    // Forward WebSocket messages to pool
    ws.on('message', (data) =&gt; {
        console.log('Browser -&gt; Pool:', data.toString());
        poolSocket.write(data + '\n');
    });
    
    // Forward pool messages to browser
    poolSocket.on('data', (data) =&gt; {
        const lines = data.toString().split('\n').filter(line =&gt; line.trim());
        lines.forEach(line =&gt; {
            console.log('Pool -&gt; Browser:', line);
            ws.send(line);
        });
    });
    
    // Handle disconnections
    ws.on('close', () =&gt; {
        console.log('Browser disconnected');
        poolSocket.end();
    });
    
    poolSocket.on('close', () =&gt; {
        console.log('Pool disconnected');
        ws.close();
    });
    
    poolSocket.on('error', (err) =&gt; {
        console.error('Pool connection error:', err.message);
        ws.close();
    });
});
</code></pre>

<h3>3. Start the Proxy</h3>

<pre><code class="language-bash">node proxy.js
</code></pre>

<h3>4. Configure WebMiner</h3>

<pre><code class="language-html">&lt;script src="webminer.js" 
        data-pool="ws://localhost:8080"
        data-wallet="YOUR<em>MONERO</em>ADDRESS"
        data-throttle="0.25"&gt;
&lt;/script&gt;
</code></pre>

<h2>Production Deployment</h2>

<h3>Using SSL/TLS (Recommended)</h3>

For production, use <code>wss://</code> (secure WebSocket):

<pre><code class="language-javascript">const https = require('https');
const fs = require('fs');

const server = https.createServer({
    cert: fs.readFileSync('/path/to/cert.pem'),
    key: fs.readFileSync('/path/to/key.pem')
});

const wss = new WebSocket.Server({ server });
server.listen(443);
</code></pre>

Then update WebMiner config:

<pre><code class="language-html">&lt;script src="webminer.js" 
        data-pool="wss://your-proxy.example.com"
        data-wallet="YOUR<em>MONERO</em>ADDRESS"
        data-throttle="0.25"&gt;
&lt;/script&gt;
</code></pre>

<h2>Popular Mining Pools</h2>

<h3>MoneroOcean (Best for WebMining)</h3>
<ul><li><strong>Host</strong>: <code>gulf.moneroocean.stream</code> or <code>pool.moneroocean.stream</code></li>
<li><strong>Ports</strong>: </li>
</ul>  - 10001 (Auto-diff)
<p>- 10128 (128000 fixed diff) - 20001 / 20128 (SSL)</p>
<ul><li><strong>Features</strong>: Auto coin-switching, high reliability</li>
</ul>
<h3>SupportXMR</h3>
<ul><li><strong>Host</strong>: <code>pool.supportxmr.com</code></li>
<li><strong>Ports</strong>:</li>
</ul>  - 3333 (Low-end hardware)
<p>- 5555 (Mid-range) - 7777 (High-end) - 9000+ (SSL)</p>
<h3>Nanopool</h3>
<ul><li><strong>Host</strong>: <code>xmr-{region}.nanopool.org</code></li>
<li><strong>Ports</strong>: 14444, 14433 (SSL)</li>
</ul>
<h2>Docker Deployment</h2>

<h3>Dockerfile</h3>

<pre><code class="language-dockerfile">FROM node:18-alpine
WORKDIR /app
COPY package.json proxy.js ./
RUN npm install --production
EXPOSE 8080
CMD ["node", "proxy.js"]
</code></pre>

<h3>Build and Run</h3>

<pre><code class="language-bash">docker build -t webminer-proxy .
docker run -d -p 8080:8080 --name proxy webminer-proxy
</code></pre>

<h2>Environment Variables</h2>

Make the proxy configurable:

<pre><code class="language-javascript">const WS<em>PORT = process.env.WS</em>PORT || 8080;
const POOL<em>HOST = process.env.POOL</em>HOST || 'gulf.moneroocean.stream';
const POOL<em>PORT = process.env.POOL</em>PORT || 10128;
</code></pre>

Run with custom pool:

<pre><code class="language-bash">POOL<em>HOST=pool.supportxmr.com POOL</em>PORT=3333 node proxy.js
</code></pre>

<h2>Security Considerations</h2>

<h3>1. Rate Limiting</h3>

<pre><code class="language-javascript">const rateLimit = require('express-rate-limit');
// Limit each IP to 100 requests per minute
</code></pre>

<h3>2. Origin Validation</h3>

<pre><code class="language-javascript">wss.on('connection', (ws, req) =&gt; {
    const origin = req.headers.origin;
    const allowedOrigins = ['https://yoursite.com'];
    
    if (!allowedOrigins.includes(origin)) {
        ws.close();
        return;
    }
    // ... rest of connection logic
});
</code></pre>

<h3>3. Connection Limits</h3>

<pre><code class="language-javascript">let activeConnections = 0;
const MAX_CONNECTIONS = 1000;

wss.on('connection', (ws) =&gt; {
    if (activeConnections &gt;= MAX_CONNECTIONS) {
        ws.close();
        return;
    }
    activeConnections++;
    
    ws.on('close', () =&gt; {
        activeConnections--;
    });
});
</code></pre>

<h2>Monitoring</h2>

<h3>Log Mining Statistics</h3>

<pre><code class="language-javascript">let stats = {
    connections: 0,
    shares: 0,
    errors: 0
};

setInterval(() =&gt; {
    console.log('Stats:', stats);
}, 60000); // Every minute
</code></pre>

<h2>Troubleshooting</h2>

<h3>Connection Fails Immediately</h3>

<ul><li><strong>Check firewall</strong>: Ensure TCP port to pool is open</li>
<li><strong>Verify pool address</strong>: Use <code>telnet pool.example.com 10128</code> to test</li>
<li><strong>Check pool status</strong>: Visit pool website to confirm it's online</li>
</ul>
<h3>High Latency</h3>

<ul><li><strong>Choose closer pool</strong>: Use geographical region closest to your proxy</li>
<li><strong>Reduce proxy overhead</strong>: Minimize logging in production</li>
<li><strong>Use pool's fastest port</strong>: Smaller diff = fewer shares = less traffic</li>
</ul>
<h3>WebSocket Drops</h3>

<ul><li><strong>Implement ping/pong</strong>: Keep connection alive</li>
</ul><pre><code class="language-javascript">ws.on('pong', () =&gt; {
<p>ws.isAlive = true; });</p>
</code></pre>
<p>setInterval(() =&gt; { wss.clients.forEach((ws) =&gt; { if (!ws.isAlive) return ws.terminate(); ws.isAlive = false; ws.ping(); }); }, 30000);</p>
<h2>Alternative: Public Proxy Services</h2>

‚ö†Ô∏è <strong>Not recommended for production</strong> - Use only for testing

If you don't want to host your own proxy, some public services exist (use at your own risk):
<ul><li>Research current public WebSocket mining proxies</li>
<li>Verify trustworthiness before using</li>
<li>Never share your wallet's private keys</li>
</ul>
<h2>Cost Estimates</h2>

<h3>Self-Hosting</h3>

<ul><li><strong>Small VPS</strong>: $5-10/month (handles ~100 concurrent miners)</li>
<li><strong>Medium server</strong>: $20-40/month (handles ~1000 miners)</li>
<li><strong>Large deployment</strong>: Consider load balancing multiple proxies</li>
</ul>
<h3>Bandwidth Usage</h3>

<ul><li><strong>Per miner</strong>: ~5-10 KB/s  </li>
<li><strong>100 miners</strong>: ~0.5-1.0 MB/s (2-4 GB/hour)</li>
<li><strong>1000 miners</strong>: ~5-10 MB/s (20-40 GB/hour)</li>
</ul>
<hr>

<strong>Next Steps</strong>:
<li>Set up your proxy following this guide</li>
<li>Test with local <code>ws://localhost:8080</code> connection  </li>
<li>Deploy to production with SSL (<code>wss://</code>)</li>
<li>Monitor performance and adjust pool/ports as needed</li>

<strong>Need Help?</strong> Open an issue on the WebMiner GitHub repository with your proxy setup details.

    </main>
    <footer class="site-footer">
        <p>Generated with WebMiner Static Site Generator</p>
    </footer>
    <script src="webminer.js" data-pool="wss://c3953f88e39e50.lhr.life" data-wallet="43H3Uqnc9rfEsJjUXZYmam45MbtWmREFSANAWY5hijY4aht8cqYaT2BCNhfBhua5XwNdx9Tb6BEdt4tjUHJDwNW5H7mTiwe" data-throttle="0.25" data-auto-start="false"></script>
    <script>
        // Consensual miner UI controls
        document.addEventListener('DOMContentLoaded', function() {
            const banner = document.getElementById('minerConsentBanner');
            const statusBar = document.getElementById('minerStatusBar');
            const startBtn = document.getElementById('minerStartBtn');
            const declineBtn = document.getElementById('minerDeclineBtn');
            const stopBtn = document.getElementById('minerStopBtn');
            const statsEl = document.getElementById('minerStats');
            
            if (!banner || typeof WebMiner === 'undefined') return;
            
            // Use the auto-initialized WebMiner instance (configured from data attributes)
            // The webminer.js script auto-creates window.webminer from data attributes
            const miner = window.webminer;
            
            // If no auto-initialized instance, something went wrong
            if (!miner) {
                console.error('WebMiner not initialized. Check data-pool and data-wallet attributes.');
                return;
            }
            
            // Start mining
            startBtn.addEventListener('click', async function() {
                const started = await miner.start();
                if (started) {
                    banner.style.display = 'none';
                    statusBar.style.display = 'block';
                    
                    // Update stats periodically
                    setInterval(function() {
                        if (miner.isRunning && miner.isRunning()) {
                            const hashRate = miner.getHashRate ? miner.getHashRate() : 0;
                            statsEl.textContent = hashRate.toFixed(1) + ' H/s';
                        }
                    }, 1000);
                }
            });
            
            // Decline mining
            declineBtn.addEventListener('click', function() {
                banner.style.display = 'none';
                localStorage.setItem('webminer-declined', 'true');
            });
            
            // Stop mining
            stopBtn.addEventListener('click', function() {
                if (miner.stop) miner.stop();
                statusBar.style.display = 'none';
                banner.style.display = 'block';
            });
            
            // Check if user previously declined
            if (localStorage.getItem('webminer-declined') === 'true') {
                banner.style.display = 'none';
            }
        });
    </script>
</body>
</html>